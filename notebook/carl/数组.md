## 0.理论基础
- 数组在内存空间的地址是连续的
- 数组中的元素只能覆盖，不能删除

## 1.循环不变量
[leetcode:704.二分查找](https://leetcode-cn.com/problems/binary-search/)

【题目描述】
> 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target， 写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

【示例】
> 输入: nums = [-1,0,3,5,9,12], target = 9
> 输出: 4
> 
> 输入: nums = [-1,0,3,5,9,12], target = 2
> 输出: -1

【思路】
> 升序数组，元素无重复，可以用二分查找。二分查找思路很简单，但边界控制容易出错，对区间的定义不清楚。
> 二分查找的区间定义一般有两种：左闭右闭，左闭右开

```cpp
// C++
int search(vector<int>& nums, int target) {
    if (nums.size() <= 0)
        return -1;

    int left = 0;
    int right = nums.size() - 1;

    while (right >= left)   // 左闭右闭
    {
        int mid = (right + left) / 2; // 索引
        if (nums[mid] == target)
            return mid;
        else if (nums[mid] > target)
            right = mid - 1;
        else
            left = mid + 1;
    }
    return -1;
}
```
```python
// python
def search(self, nums: List[int], target: int) -> int:
    left = 0
    right = len(nums) - 1

    while right >= left:
        mid = (right + left) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] > target:
            right = mid - 1
        else:
            left = mid + 1
    return -1
```

[leetcode:59.螺旋矩阵II](https://leetcode-cn.com/problems/spiral-matrix-ii/)

【题目描述】
> 给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。

【示例】
> 输入：n = 3
> 输出：[[1,2,3],[8,9,4],[7,6,5]]
>
> 输入：n = 1
> 输出：[[1]]

【思路】
> 题目解法很简单，就是模拟螺旋顺序打印的过程，一圈一圈的旋转，难点在于边界条件的控制，需要按照固定规则遍历，也就是确定循环不变量
> 循环画矩阵过程：
> 1. 从左到右填充上行
> 2. 从上到下填充右列
> 3. 从右到左填充下列
> 4. 从下到上填充左列
> 循环不变量：左闭右开，即一行/一列，第一个元素在当前边遍历时处理，最后一个元素不再当前边遍历时处理

```cpp
// C++
vector<vector<int>> generateMatrix(int n)
{
    vector<vector<int>> res(n, vector<int>(n, 0));
    int startX = 0;     // 每一圈起始坐标
    int startY = 0;
    int offset = 1;     // 每一圈长度
    int loop = n / 2;   // 总圈数
    int i,j;
    int mid = n / 2;    // 奇数时最中间单独赋值
    int count = 1;     // 赋值
    
    //  转圈
    while(loop--)
    {
        i = startX;
        j = startY;

        // 模拟转一圈
        // 上侧从左至右
        for( ; j < n + startY - offset; j++ )
            res[i][j] = count++;

        // 右侧从上至下
        for( ; i < n + startX - offset; i++ )
            res[i][j] = count++;

        // 下侧从右至左
        for( ; j > startY; j-- )
            res[i][j] = count++;

        // 左侧从下至上
        for( ; i > startX; i-- )
            res[i][j] = count++;

        // 下一轮起始坐标
        startX++;
        startY++;

        // 下一轮一圈每条边长度
        offset += 2;
    }

    // n 为奇数，最中心单独赋值
    if ( n % 2 == 1 )     
        res[mid][mid] = count;

    return res;
}
```
```python
# python
def generateMatrix(self, n: int) -> List[List[int]]:
    res = [[0] * n for _ in range(n)]  # 初始化二维数组
    startX, startY, i, j = 0, 0, 0, 0  # 每轮循环起始坐标，转圈坐标
    loop = mid = n // 2  # 循环次数，最中心网格位置
    offset = 1  # 控制每条边长度
    count = 1  # 赋值

    while loop:
        i, j = startX, startY

        # 开始一轮循环
        # 上侧自左向右
        for j in range(startY, startY + n - offset):
            res[i][j] = count
            count += 1
        j += 1

        # 右侧自上向下
        for i in range(startX, startX + n - offset):
            res[i][j] = count
            count += 1
        i += 1

        # 下册自右向左
        for j in range(startY + n - offset, startY, -1):
            res[i][j] = count
            count += 1
        j -= 1

        # 左侧自下向上
        for i in range(startX + n - offset, startX, -1):
            res[i][j] = count
            count += 1
        i -= 1

        startX += 1
        startY += 1
        loop -= 1

    if n % 2 == 1:
        res[mid][mid] = count

    return res
```

## 2.双指针法
[leetcode:27.移除元素](https://leetcode-cn.com/problems/remove-element/)

【题目描述】
> 给你一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，并返回移除后数组的新长度。
> 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。
> 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

【示例】
> 输入：nums = [3,2,2,3], val = 3
> 输出：2, nums = [2,2]
> 
> 输入：nums = [0,1,2,2,3,0,4,2], val = 2
> 输出：5, nums = [0,1,4,0,3]

【思路】
> 1. 暴力解法：两个 for 循环，第一个循环遍历数组，第二个循环移动数组
> 2. 双指针（快慢指针）：快指针，遍历数组; 慢指针，维持当前数组中慢指针之前区间所有元素不等 val; 当快指针遇到不等于 val 值的元素时，交换至慢指针，慢指针再移动一次
> 3. 双指针（首尾指针）：首指针，从前往后遍历；尾指针，从后往前遍历，直至首尾指针相遇。当首指针等于 val 时，将尾指针的值交换至首指针，尾指针前移，首指针值不等于 val 时后移

```cpp
// C++
// 快慢指针
int removeElement2(vector<int>& nums, int val) {
    int slowIndex = 0;
    for (int fastIndex = 0; fastIndex < nums.size(); fastIndex++)
    {
        if ( val != nums[fastIndex] )
            nums[slowIndex++] = nums[fastIndex];
    }
    return slowIndex;   // 不需要 +1
}

// 首尾双指针，能避免不必要的移动
int removeElement(vector<int> &nums, int val)
{
    int firstIndex = 0;
    int lastIndex = nums.size() - 1;

    while (firstIndex <= lastIndex)
    {
        if (nums[firstIndex] == val)
        {
            int temp = nums[firstIndex];
            nums[firstIndex] = nums[lastIndex];
            nums[lastIndex] = nums[firstIndex];
            lastIndex--;
        }
        else
            firstIndex++;
    }
    return firstIndex;
```
```python
# python
def remove_element(nums: List[int], val: int) -> int:
    slow_index = 0
    for fast_index in range(0, len(nums)):
        if val != nums[fast_index]:
            nums[slow_index] = nums[fast_index]
            slow_index += 1
    return slow_index


def remove_element2(nums: List[int], val: int) -> int:
    last_index, first_index = len(nums) - 1, 0
    while first_index < last_index:
        if nums[first_index] == val:
            nums[first_index] = nums[last_index]
            last_index -= 1
        else:
            first_index += 1
    return first_index
```

## 3.滑动窗口
[leetcode:209.长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)
【题目描述】
> 给定一个含有 n 个正整数的数组和一个正整数 target 。
> 找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。

【示例】
> 输入：target = 7, nums = [2,3,1,2,4,3]
> 输出：2
>
> 输入：target = 4, nums = [1,4,4]
> 输出：1
>
> 输入：target = 11, nums = [1,1,1,1,1,1,1,1]
> 输出：0

【思路】
> 1. 暴力解法：两个 for 循环
> 2. 滑动窗口

```cpp
// C++
/**
 * 滑动窗口 3 要素：
 * 1. 窗口内元素
 * 2. 如何移动窗口起始位置？
 * 3. 如何移动窗口终止位置？
 * 
 * 本题：
 * 1. 窗口内是和大于等于 target 的元素
 * 2. 移动起始位置：当前窗口和大于等于 target
 * 3. 移动终止位置：当前窗口和小于 target
 * 通过终止位置遍历指针
 */ 
int minSubArrayLen(int target, vector<int>& nums) {
    int result = __INT32_MAX__;
    int sum = 0;
    int subLength = 0;
    int startIndex = 0;
    for (size_t i = 0; i < nums.size(); i++)
    {
        sum += nums[i];
        while ( sum >= target ){
            subLength = i - startIndex + 1;
            result = result < subLength ? result : subLength;
            sum -= nums[startIndex++];
        }
    }
    return result == __INT32_MAX__ ? 0 : result; 
}
```
```python
# python
def minSubArrayLen(self, target: int, nums: List[int]) -> int:
    result = sys.maxsize
    start_index, sub_length, sum = 0, 0, 0
    for i in range(0, len(nums)):
        sum += nums[i]
        while sum >= target:
            sub_length = i - start_index + 1
            result = result if result < sub_length else sub_length
            sum -= nums[start_index]
            start_index += 1
```
