## 1. 数组理论基础
[数组理论基础](https://www.programmercarl.com/%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80)
- 数组是存放在连续内存空间上的相同类型数据的集合。
- 数组下标都是从0开始的。
- 数组内存空间的地址是连续的。正是因为数组在内存空间的地址是连续的，所以删除或者增添元素的时候，需要移动其他元素的地址。
- 数组的元素是不能删的，只能覆盖。
- C++中二维数组在地址空间上是连续的。

## 2. 二分查找
[leetcode 题目链接](https://leetcode-cn.com/problems/binary-search/)
**【题目描述】**
> 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。
> **示例 1:**
> 输入: nums = [-1,0,3,5,9,12], target = 9
> 输出: 4
> 解释: 9 出现在 nums 中并且下标为 4
>
> **示例 2:**
> 输入: nums = [-1,0,3,5,9,12], target = 2
> 输出: -1
> 解释: 2 不存在 nums 中因此返回 -1
>
> **提示：**
> 1. 你可以假设 nums 中的所有元素是不重复的。
> 2. n 将在 [1, 10000]之间。
> 3. nums 的每个元素都将在 [-9999, 9999]之间。

**【思路】**
二分查找思路很简单，实现时需要注意的是边界条件控制。也就是边界 [left,right)、[left,right\] 是开还是闭的问题。
```cpp
int binarySearch(vector<int>& nums, int target) {
    if (nums.size() <= 0)
        return -1;
    
    // [left,right]，左闭右闭
    int left = 0;
    int right = nums.size() - 1;

    while (right >= left)
    {
        int mid = ((right - left) >> 2) + left; // 防止 left + right 越界
        if (nums[mid] == target)
            return mid;
        else if (nums[mid] > target)
            right = mid - 1;
        else
            left = mid + 1;
    }
    return -1;
}
```

## 3. 二维数组中的查找
[nowcoder 题目链接](https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=295&tqId=23256&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Ftab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)
**【题目描述】**
> 在一个二维数组 array 中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排列，每一列都按照从上到下递增的顺序排列。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
> [[1,2,8,9],
>  [2,4,9,12],
>  [4,7,10,13],
>  [6,8,11,15]]
> 给定 target = 7，返回 true。
> 给定 target = 3，返回 false。

**[思路]**
以右上角为顶点，会发现同一行中左侧元素小于该顶点，同一列中下面元素大于该顶点，因此可以使用二分法，以右上角或者左下角为起点，利用二分法思想不断移动。
```cpp
bool Find(int target, vector<vector<int> > array) {
    int left = 0;
    int right = array[0].size()-1;
    while(left < array.size() && right >= 0)
    {
        if(array[left][right] > target)
            right--;
        else if(array[left][right] < target)
            left++;
        else
            return true;
    }
    return false;
}
```

## 4. 数组中的逆序对
[nowcoder 题目链接](https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?tpId=295&tqId=23260&ru=%2Fpractice%2F9f3231a991af4f55b95579b44b7a01ba&qru=%2Fta%2Fformat-top101%2Fquestion-ranking&sourceUrl=%2Fexam%2Foj%3Ftab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)
**【题目描述】**
> 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数P。并将 P 对 1000000007 取模的结果输出。即输出P mod 1000000007
>
> 数据范围：对于 50\%50% 的数据, size≤10^4
> 对于 %100 的数据, size≤10^5
> 数组中所有数字的值满足 0 ≤ val ≤ 1000000
> 要求：空间复杂度 O(n)，时间复杂度 O(nlogn)
>
> **示例1**
> 输入：[1,2,3,4,5,6,7,0]
> 返回值：7
>
> **示例2**
> 输入：[1,2,3]
> 返回值：0
**【思路】**
利用归并排序思想。归并排序分为划分和归并两个部分。其中在对两个区间归并时，两个区间分别都已经有序，并且此时归并两个区间的思想是依次找出两个区间中最小的值，按序赋给新的临时数组。在两个有序待归并的区间中依次找出最小值时就可以计算出逆序对。
```cpp
int InversePairs(vector<int> data)
{
    int result = 0;
    int len = data.size();
    vector<int> b(data.size());
    // 划分
    for (int seg = 1; seg < data.size(); seg += seg)
    {
        // 两两 seg 之间归并,[start,mid)[mid,high)
        for (int start = 0; start < len; start += seg + seg)
        {
            int mid = min(start + seg, len);
            int high = min(start + seg + seg, len);
            int start1 = start, start2 = mid;
            int k = start;
            while (start1 < mid && start2 < high)
            {
                if (data[start1] > data[start2])
                {
                    b[k++] = data[start2++];
                    // 核心：归并的时候，两两区间都已经有序，如果 pre 区间中某个数值大于 last 区间某个数值，那个 pre 区间中那个数值之后的所有数值均会大于 last 区间的那个数值
                    result += mid - start1;     // 注意是 [mid,start1) 区间，不需要 +1
                    result += mid - start1;
                    result %= 1000000007;
                }
                else
                    b[k++] = data[start1++];
            }

            while (start1 < mid)
                b[k++] = data[start1++];

            while (start2 < high)
                b[k++] = data[start2++];
        }

        // 将完成一层归并的临时数组赋值给原来数组
        for (int i = 0; i < data.size(); i++)
            data[i] = b[i];
    }
    return result;
}
```

## 5. 旋转数组的最小数字
[nowcoder 题目链接](https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=295&tqId=23269&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Ftab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)
**【题目描述】**
> 有一个长度为 n 的非降序数组，比如[1,2,3,4,5]，将它进行旋转，即把一个数组最开始的若干个元素搬到数组的末尾，变成一个旋转数组，比如变成了[3,4,5,1,2]，或者[4,5,1,2,3]这样的。请问，给定这样一个旋转数组，求数组中的最小值。
> 
> 数据范围：1≤n≤10000，数组中任意元素的值: 0≤val≤10000
> 要求：空间复杂度：O(1) ，时间复杂度：O(logn)

**【思路】**
- 原本数组是有序状态，进行旋转后，假设原数组旋转点前一部分为 B,后一部分为 A，那么数组将由 [B, A] 变为 [A, B]，其中 B 中所有元素将严格 ≤ A。此时依旧部分有序，可以用二分法来做此题。
- 二分法的关键在于和哪个数比较的问题，一般的比较原则有：
  - 如果有目标值target，那么直接让arr[mid] 和 target 比较即可。
  - 如果没有目标值，一般可以考虑端点
  - 此题 B 中元素严格 ≤ A，可以用右端点作为目标值。不能用左端点，左端点和目标点(最小)处于一个上升区间。
  - 数组中存在重复元素，当 arr[mid] 和 target 相等时，可以从右端点慢慢缩小区间。
```cpp
int minNumberInRotateArray(vector<int> rotateArray) {
    int left = 0;
    int right = rotateArray.size() - 1;
    // [left, right) 左闭右开区间
    while (left < right)
    {
        int mid = ((right - left) >> 1) + left;
        if (rotateArray[mid] > rotateArray[right])  //  target 在右区间
            left = mid+1;
        else if(rotateArray[mid] < rotateArray[right])  // target 在左区间
            right = mid;
        else  // 慢缩小
            right--;
    }
    return rotateArray[left];
    // return rotateArray[left] > rotateArray[right] ? rotateArray[right] : rotateArray[left];
}
```